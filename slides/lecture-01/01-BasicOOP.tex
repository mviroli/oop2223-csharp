\documentclass[presentation]{beamer}
\usepackage{common}

\title[\lecturecode{01}]{01 \\ Basic object-oriented programming, in C\#}

\author[Mirko Viroli]{Mirko Viroli}
\institute[]{\texttt{mirko.viroli@unibo.it}}

\begin{document}

\frame[label=coverpage]{\titlepage}
\newcommand{\codepath}[1]{../../code/lecture-01/#1}

\section{On engineering software systems}

\fr{The need of good ``software methods''}{
  \bl{Problems with developing software}{\iz{
   \item software tends to be very complex
   \item pieces of software are often easy to ``somewhat prototype''
   \item software is error prone, and often very difficult to debug
   \item the time from prototype to correct deployed software can be huge
  }}
  \bl{Results}{\iz{
    \item software projects fail
    \item i.e., they ``run away'', they are not appreciated hence used
  }}
  \bl{Learning from experience}{\iz{
   \item what is the software ``quality'' that leads to successful projects?
   \item what are good programming techniques to promote quality?
  }}
}

\fr{Steps of all software development processes}{
  \bl{Analysis (requirements elicitation and engineering)}{\iz{
   \item understanding the \alert{problem}, by gathering requirements and understanding/analysing/organising them 
  }}
  \bl{Design}{\iz{
    \item defining the key elements of the \alert{solution}: a software system 
    \item by incremental refinement: from architecture to details
  }}
  \bl{Implementation}{\iz{ 
    \item actual \alert{development}: choosing technologies and coding
  }}
  \bl{Post-implementation}{\iz{
    \item testing, deployment, maintenance
    }}
}

\frs{2}{The key issue of software development}{
   \bl{Key facts on software engineering}{\iz{
      \item little increase in problem complexity may lead to significant problem in solution
      \item projects tend to runaway because of instability of requirements and optimistic estimation
      \item if not properly handled, error detection and removal can grow to 40\% of development
      \item if not properly handled, maintenance can consume up to 80\% of overall cost of development
   }}
   \bl{Making development a much more controlled process}{\iz{
      \item focus on tools/methods to make software development a traced process
      \item focus on making software ready to change and maintenance
      \item focus on more easily detect and remove errors
   }}
}

\fr{A case study: Smart Home Controller (SHC)}{
    \bl{Main requirements}{\iz{
        \item build the logic's of a control panel for a smart home
        \item by simple touches, it allows to control many devices
        \item devices: lamps, TVs, air conditioners
        \item view: getting the state of the various devices
        \item commands: switch on/off, regulate, schedule events, handle failures
    }}
}

\frs{5}{Problem space vs solution space: the ``good project''}{
  \bl{Problem space (analysis phase)}{
   The set of entities/relations/processes in the ``real'' world that the software system must address
   \iz{
   \item In SHC:
lamps, devices, control panel, luminosity, device failure
   }
  }
  \bl{Solution space (design and implementation phase)}{
    The corresponding set of entities/relations/processes in the ``artificial'' world that the software is built upon (realized through the languages and technologies chosen and in the face of the project).
    \iz{
        \item function for calculating expected lifetime of a device
        \item data structure to represent device position in the house
        \item interrupts to intercept human interaction with the control panel
   }
  }
  \bx{\bf{A good project best maps the problem space into the solution space}}
}

\fr{Solution space, and the programming language}{
  \bl{Abstraction and programming}{\iz{
    \item Each programming language introduces a so-called \alert{level of abstraction}:\\
    $\Rightarrow$ a set of constructs by which the designer selects and conveniently describes the system in question
     \item A programming language is hence a language to express concepts in solution spaces
     \item Programming is about turning the problem space into the solution space
    \item Is it easy? Is it convenient? Is it flexible? \\ It depends on the language ..
  }}
}

\fr{The case of C language}{
  \bl{The level of abstraction of C (and of structured programming)}{\iz{
    \item System state | it consists of data structures (built with primitive types, arrays, pointers and structs) kept in stack and/or heap
    \item Dynamics | execution of imperative procedures, recursively ``grafted'' by leaning on the stack
    \item Organization | libraries as a set of functions/procedures, reunited in a single program at the time of compilation/linking
  }}
}

\frs{5}{The limits of the C language}{
  \bl{C leads to a rather machine-oriented view}{\iz{
    \item It is a level of abstraction strongly influenced by the HW on which the programs (CPU, memory) are executed
    \item Essentially, with C you run programs on a HW, you do not express domains
    \item Necessarily, since C was design in the 70s to replace Assembly to implement Unix O.S.
    \item Nowadays, this leads to various inadequacies, and the impossibility of true software quality
   {\iz{
      \item dynamic memory allocation / deallocation via libraries
      \item difficulty in intercepting execution errors
      \item difficulty in controlling HW-dependent aspects
      \item difficulty in modifying/evolving already ``acquired'' code
    }}
  }}
  \bl{The direction of modern - or `` high level '' (abstraction) languages}{\iz{
    \item Introduce a level of abstraction closer to the problem to be solved, ignoring as much as possible the details of the HW to solve it
  }}
  }
  
\frs{10}{The ecosystem of programming languages}{
\bl{Languages and levels of abstraction/paradigm}{\iz{
    \item C, Pascal: Computing function / procedure over data structures
    \item Lisp, ML: Everything is a function, computing by function-call
    \item Prolog: Everything is a decision predicate to be solved
    \item C++, C\#, Java: Everything is an object (OO Programming)
    \item [$\Rightarrow$] OOP has proved ideal for complex, general-purpose systems
  }}
  \bl{The evolution of the mainstream}{
  Machine Lang $\xrightarrow{'50 -'60}$ Assembly $\xrightarrow{'70 -'80}$ C $\xrightarrow{'90-2000}$ OOP $\xrightarrow{'10-'20}$ OOP(+FP)
  }
  \bl{The trend of OOP languages}{\iz{
    \item Adding functional mechanisms and practice in OOP 
    \item Started with Scala, then with Java/C\# generics+lambdas, and recently Kotlin
  %\item Scripting languages (Python, Ruby, Groovy): not really for engineering complex systems
  }}
}

\fr{The advantages of object-oriented programming}{
  \bl{Advantages}{\iz{
    \item Few key abstractions (class, object, method)
    \item Usable both in design and in coding
    \item Support for extensibility and reuse of code
    \item Support for building quality libraries
    \item Easily integrated into C-like languages
    \item Executable with high efficiency
    \item [$ \Rightarrow $] all aspects that we will explore...
}}
  \bl{The criticisms of the OOP}{\iz{
    \item It needs a lot of discipline to ``scale well'' with the complexity of the problem, that is, to avoid running into manageability problems as the complexity of the system to be implemented increases
    \item This justifies the need of ``engineering'' aspects
}}
}

\section{The object-oriented abstraction}



\fr{The Object-oriented (OO) abstraction}{
   \bx{
   \Huge An object has state, \\behavior and identity.
   }
}

\fr{More detailed definition}{
   \bx{\en{
    \item{\bf Everything is an object.} An object is an entity that provides operations to be manipulated.
    \item{\bf A program is a set of objects that tell each other what to do by exchanging messages.} These messages are requests to perform the operations provided.
    \item{\bf An object has a memory made up of other objects.} An object is obtained by packing other object together.
    \item{\bf Each object is an instance of a class.} A class describes the behavior of its objects.
    \item{\bf All objects in a class can receive the same messages.} The class indicates among other things what operations are provided, so to communicate with an object you just need to know what its class is.
   }}
} 

\fr{Object and object system}{
  \fg{width = 0.9 \textwidth}{img/objects.pdf}
}


\fr{Are these concepts useful for problem space?}{
    \bl{Example of a real system: the smart house application}{\iz{
        \item How should it be organised? What services does it provide?
    }}
    \bl{Object-oriented view}{\iz{
        \item The control panel is an ``object''
        \item What operations does it allow? Show all device, switch off all devices, switch on a specific device,...
        \item A program (system) is made up of objects: control panel, lamps, TVs, air conditioners,...
        \item The interactions between these objects are ``message exchanges''
        \item A lamp has a status made up of other objects: on/off flag, counter of switches, luminosity
        \item A specific lamp is an instance of a class: the class of all lamps - the control panel manages dozens of them simultaneously
    }}
}


\fr{OO: problem space, solution space}{
    \bl{Experience shows that:}{\iz{
\item It is quite easy to model real (or artificial) systems as object-oriented systems
\item In fact, standard modeling tools use the object-oriented paradigm! (See UML)
    }}
    \bl{The advantage of object-oriented solutions}{\iz{
\item They allow you to ``bring'' the problem space into the solution space directly
\item Using the same object-oriented concepts also at the programming level
\item ...that is, they support the concept of ``good design'' we have discussed
    }}
}


\fr{Overview}{
\bx{\en{
\item Each object has an interface
\item An object provides a service
\item An object must hide the implementation
\item Implementations can be reused
\item Reuse through inheritance
% \item Polymorphism and substitutability
% \item The single-rooted class hierarchies
% \item The Containers
}}
}

\frs{5}{Each object has an interface}{
  \bl{Classes, instances, methods, interface}{\iz{
    \item Similar objects are instances of the same \alert{class}, or \alert{type}
    \item The class defines the receivable messages, through \alert{methods}
    \item The set of methods is called \alert{interface}
    \item A message affects the state and behavior of the object
  }}
  \bx{Example ``lamp'' in UML (Unified Modeling Language) notation:}
  \fg{width = 0.6\textwidth}{img/light.png}
}

\frs{5}{An object provides a service}{
  \bl{Which problem space entity should become an object?}{\iz{
    \item It is convenient to consider an object as a service provider
    \item The whole program can be seen as a service given to the user
    \item Principle of decomposition: the sub-services are entrusted to the various objects
  }}
  \bl{Advantages of this approach}{\iz{
    \item Simplify object design, and problem mapping
    \item Simplify their reuse in different programs - as part of a library
    \item Makes it easier to understand programs, especially by third parties
  }}
  \bx{{Opportunity: $ \Rightarrow $ If you can't describe the service, then probably an object has no reason to exist!} \\
     {Consistency: $ \Rightarrow $ If it appears that one object performs two different services, then you probably need to actually make two objects!}}
}

\frs{5}{An object must hide the implementation}{
  \bl{The two figures: class creator vs. client programmer}{
  \iz{
    \item One produces the class (and is responsible for its operation)
    \item The other uses the class (to provide a higher level service)
  }}
  \bl{Information hiding}{\iz{
  \item The creator makes only a small part of the class visible
  \item The rest are invisible as they are subject to future changes
  \item Principle: ``less is more''
  \item Typical structure of a class \iz{
   \item interface: the only part visible to the client
   \item \alert{fields} of the class (the sub-objects of which it is made up)
   \item method implementation (what the object does when it receives messages){\iz{
    \item how status changes (members)
    \item what messages it sends to other objects
    \item what result it gives (reply to message)
   }}
   
  }
  }}
}

\frs{10}{Implementations can be reused}{
  \bl{Stages of the reuse process}{
  \en{
    \item The creator produces a class and verifies that it works correctly: it becomes a reusable unit of code
    \item A client can re-use it to create new concepts
  }}
  \bl{The most used reuse technique is \alert{composition}}{\iz{
  \item A new object consists of objects of other classes
  \item Relation called ``has-a'' (``has a'')
  \item This relationship can be hidden, and made dynamic
  }}
  \bx{Example ``car + engine'' in UML notation:}
  \fg{width = 0.6\textwidth}{img/car.png}
}

\frs{15}{Reuse through inheritance}{
   \bl{It is a further, fundamental, reuse technique}{\iz{
   \item A new object (/class) extends the services of an existing one
   \item Provides the methods of the supra-class, but also others
   \item Called ``is-a'' relationship
   }}
   \bx{Example ``shape'' in UML notation:}
   \fg{width = 0.4 \textwidth}{img/shape.png}
}

\section{C\# brief introduction: values and variables}

\frs{5}{Brief introduction to C\#}{
  \bl{C\#}{\iz{
    \item Designed by Anders Hejlsberg around 2000 at Microsoft
    \item Is part of the .NET initiative, designed to compile over the Common Language Infrastructure (CLI)
    \item Current version is 9.0, released in 2020 for .NET 5.0
    \item Mono is a free, open-source compiler and runtime environment
    \item Initially developed as very similar to Java, then somewhat diverged
    }}
  \fg{height = 0.4\textheight}{img/NET.jpg}
}

\frs{20}{Features of C\#}{
  \bl{Ingredients}{\iz{
    \item C-like language: the imperative and structured part are very similar
    \item Static and strong typing: types are checked at run-time, preventing ill-typed operations
    \item Object-orientation: object by references, automatic garbage collection
    \item Functional-orientation: extension methods, generics, delegates, lambdas
    }}
  \bl{Philosophy}{\iz{
    \item aiming at high expressiveness and richness, though become a rather ``large'' language
  }}
  \fg{height = 0.4\textheight}{img/sizes.png}
}


\frs{5}{Variables, objects, and primitive values}{
  \bl{Basic concepts}{\iz{
  \item Value: a store of information (\texttt{0}, \texttt{1}, \texttt{"aaa"}, \texttt{<Lamp547>})
  \item Type: a categorization of all possible values (\texttt{int}, \texttt{String}, \texttt{Lamp}), in two fashion {\iz{
  \item Reference types: their values are objects (\texttt{String}, \texttt{Lamp})
  \item Value types: their values are bits of information (\texttt{int}, \texttt{bool},..)
  }}
  \item Variable: a container with a name (as in C), usable to denote a value of some type{\iz{
    \item with reference types, they contain references (addresses) of the object
    \item with value types, directly the bits
  }}
  }}
  %\sizedrangedcodei{\scriptsize}{9}{20}{\codepath{ConsoleApp1/Program.cs}}
  \codeview{3}{9}{15}{\scriptsize}{\codepath{InitialExamples/Variables.cs}}
  }

\fr{C\# types: we start with Simple Types and Class Types}{
  \fg{height = 0.6\textheight}{img/datatypes.png}
}
  
\frs{20}{Variables: initialisation and inference}{
  \bl{On variables}{\iz{
  \item In OOP, variables are local names given to refer to objects
  \item One can initialise them as soon as they are defined, or later, multiple times
  \item Variables cannot be used unless initialised
  \item A variable can be initialised with an expression, possibly complex
  \item \texttt{null} is assignable to variables of reference types
  \item Can use \texttt{var} to declare a variable with type to be inferred
  }}
  \codeview{3}{9}{23}{\scriptsize}{\codepath{InitialExamples/Initialisation.cs}}
}

\fr{Objects and memory}{
  \bl{Memory management - we enter the CLR only temporarily}{\iz{
    \item all objects are allocated in the \alert{heap} memory
    \item the variables are allocated on the stack, in their respective activation records
    \item variables of value types directly contain the value
    \item variables that contain objects actually have a reference to the heap
    \item note: we still don't know what an object contains
  }}
  \bl{Situation regarding the code of the previous slide}{\iz{
    \item \cil{s} and \cil{s2} both eventually have a reference to \texttt{"aaa"}
    \item no variable has a reference to \texttt{"bbb"} or \texttt{"ccc"}
    \item \cil{i} holds no reference, but bits representing number $7$
  }}
}

\fr{Visibility, i.e. ``scope'', of variables}{
  \bl{Defined a variable, where will it be visible?}{\iz{
    \item Rules very similar to those of C
    \item variables inside a block are not visible outside
    \item unlike C: uninitialised variables are not usable!
  }}
  \bl{Lifetime of objects}{\iz{
    \item Once the scope of the variable have been executed, the object continues to exist
    \item it will be automatically deallocated by the system if no longer used{\iz{
        \item if, directly or indirectly, no variable can reach it
        \item a component of the CLR, the \alert{garbage collector}, is in charge of this task
        \item we will see how it works..
    }}
  }}
}

\section{An OO core of C\#}

\fr{Building classes}{
  \bl{Premises} {\iz{
    \item the \alert {class} is the fundamental unit of OO programming
    \item designing and building classes correctly will be the goal of the course
    \item we begin by describing their general structure
    \item we will gradually give more and more precise guidelines
  }}
  \bl{What is a class} {\iz{
    \item it is a template for generating objects of a certain ``shape''
    \item defines type, structure in memory and behavior of those objects
  }}
  \bl{Class vs. object} {\iz {
    \item class: is a description (part of the program)
    \item object: is a runtime entity, it is \alert {instance} of a class
  }}
  
}


\fr {Structure of a class} {
  \bl {Name of the class} {
  it is also the name of the type
  }
  \bl{Class members} {
    \alert {Fields}  {\iz {
      \item they describe the structure / state of the object in memory
    }}
    \alert {Methods} {\iz {
      \item describe accepted messages and corresponding behavior
    }}
   }
}

\frs{5}{Classes define types}{
Constructing classes:
  \codeview{1}{19}{27}{\footnotesize}{\codepath{InitialExamples/Classes.cs}}
Using classes:  
  \codeview{3}{9}{15}{\footnotesize}{\codepath{InitialExamples/Classes.cs}}
}

\frs{15}{Fields} {
   \bl {Constituent elements of fields} {\iz {
     \item the fields of a class resemble the members of a struct of C
     \item each is a kind of variable (name + type) 
     \item there can be 0.1, many
     \item the state of an object is the current value associated with the fields
     \item could be of reference or value types
     \item are preceded by a visibility modifier (which are many, which we will all see):{\iz{
        \item \texttt{public}, meaning it can be observed from outside the class
        \item \texttt{private}, meaning it can't be observed from outside the class
        }}
   }}
   \bl {Value of a field} {\iz {
     \item settable at the time of its declaration
     \item if not initialized it is:
     {\iz {
       \item \cil {0} for numeric types
       \item \cil {false} for Booleans
       \item \cil {null} for classes
     }}
     \item accessible from client code with \alert {obj.field} notation
   }}
   }

\fr{A simple toy class}{
Class:
  \codeview{1}{21}{27}{\footnotesize}{\codepath{InitialExamples/Fields.cs}}
Use:  
  \codeview{3}{9}{17}{\scriptsize}{\codepath{InitialExamples/Fields.cs}}
}

\fr{A slightly more realistic example}{
  \codeview{1}{23}{28}{\footnotesize}{\codepath{InitialExamples/Point3DFields.cs}}
  \codeview{3}{9}{19}{\scriptsize}{\codepath{InitialExamples/Point3DFields.cs}}
}


\frs{5}{Methods} {
   \bl {Constituent elements of methods} {\iz {
     \item the methods of a class resemble functions (of C)
     \item each has a \alert {header} (signature) and a \alert{body} (body) {\iz {
      \item in turn the header has the name, return type, arguments
     }}
     \item a class can have 0, 1, or many methods
     \item they altogether define the behavior of the object
     \item each method has a visibility modifier likewise fields
   }}
   \bl {Meaning of a method} {\iz {
     \item client code calls a method with notation \alert{obj.meth(args)}
     \item this is equivalent to sending a message to \cil{obj}
     \item \cil{obj}, called the \alert{receiver} of the message, is called (invoked)
     \item the consequent behavior is given by the execution of the body
     \item the body can read/write the value of the fields of \cil{obj}
   }}
   } 

\fr{Toy example with methods}{
  \codeview{1}{18}{26}{\footnotesize}{\codepath{InitialExamples/Methods.cs}}
  \codeview{3}{9}{14}{\scriptsize}{\codepath{InitialExamples/Methods.cs}}
}

\frs{15}{The special variable \Cil {this}} {
   \bl {\cil {this}} {\iz {
     \item inside a method you can access arguments or fields
     %\item access of a field is syntactically equivalent to access to a variable/argument
     \item to make the syntax less ambiguous, OOP langs and C\# provide a special variable denoted by \cil{this},  which contains the reference to the object that is handling the current message
     \item for readability reasons, we shall use it thoroughly
   }}
  \codeview{1}{18}{30}{\footnotesize}{\codepath{InitialExamples/MethodsThis.cs}}
}

\fr{Public or private?}{
  \bl{A very, very important issue...}{\iz{
    \item it pertains fundamental aspects of information hiding, encapsulation, and dependency (which we will explore)
  }}
  \bl{Typical approach, we should better use from now}{\iz{
    \item fields are declared \cil{private}
    \item methods are declared \cil{public}
  }}
}


\frs{10}{Point3D with methods}{
  \codeview{1}{18}{37}{\ssmall}{\codepath{InitialExamples/Point3DMethods.cs}}
  \codeview{3}{9}{14}{\ssmall}{\codepath{InitialExamples/Point3DMethods.cs}}
}

\fr {C\# executable programs} {
   \bl {Building blocks of C\# software} {\iz {
     \item class libraries shipped with .NET
     \item possibly other external libraries 
     \item a set of classes that make up the application we build (like \cil{Point3D)}
     \item at least one of these classes has a special method \cil{Main}
     \item a \cil {Main} is the entry point of a program
   }}
   \bl{The \cil {Main} must have the following declaration: }{\iz {
   \item \cil {public static void Main() \{.. \}}
    \item there could be variant with different inputs, outputs, and visibility, but we won't see them now
    \item it is key it is call \cil{Main} and is \cil{static}
    \item \cil{static} means this method is ``shared'' among all objects, and is conceptually called to the class, not to the object
   }}
}

\frs{15}{Typical structure of an executable project} {
   \bl{Entry point class} {\iz {
     \item it contains the \cil{Main} method
     \item typically, it contains only that method
   }}
   \bl{Other classes}{\iz{
     \item contain the various application classes
   }}
   \bl{Source files}{\iz{
    \item have \cil{.cs} extension
    \item start with ``\cil{using}'' clauses to declare other classes they use
    \item declared one or more classes, enclosing them in \cil{namespace}s
    \item a \cil{namespace} is a ``module'' giving a context to the class
   }}
   \bl{Project}{\iz{
    \item has a name
    \item has one or many sources
    \item specify additional properties, and dependencies (references to other projects)
   }}
}

\fr{The \Cil{HelloWorld} program}{
%\codeview{0}{1}{100}{\small}{\codepath{HelloWorld/Program.cs}}
\codeview{0}{2}{14}{\scriptsize}{\codepath{HelloWorld/Program.cs}}
    \bl{Elements} {\iz {
     \item the \cil{Main} calls static method \cil{WriteLine} to the class \cil{Console}, passing a \cil{String}
     \item class \cil{Console} is defined in the standard library, inside namespace \cil{System}, which we \cil{use}
   }}
}

\frs{10}{Playing with libraries (namespace \Cil{System})}{
\codeviewall{\tiny}{\codepath{PlayWithLibraries/Program.cs}}
}


\frs{5}{Conventions} {
   \bl {Code conventions} {\iz {
     \item They concern indentation, comments, declarations, naming conventions
     \item They improve readability, and therefore understanding
     \item It is crucial that they are followed
     \item \myurl {https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions}
   }}
   \bl {We will see them gradually... for now:} {\iz {
     \item One instruction per line
     \item Formatting curly brackets exactly as shown
     \item Classes, methods, namespaces: upper CamelCase
     \item Variables, arguments: lower camelCase
     \item Fields: lower camelCase starting with an underscore
     \item use of \cil{this} only if really necessary
   }}
} 

\frs{5}{Playing with our examples so far: \Cil{Point3D}}{
\codeviewall{\tiny}{\codepath{FirstPoint3D/Program.cs}}
}


\section{Additional OOP features}


\frs{5}{The problem of initialising objects}{
\codeview{1}{5}{35}{\tiny}{\codepath{Point3DFluent/Program.cs}}
}

\fr{The problem of initialising objects}{
    \bl {The \cil{new} operator} {\iz {
      \item As we currently know, it creates an object by initialising all its fields to their default value (e.g. $0$ for numbers), and returns the reference of this object
      \item Other methods must handle the actual initialisation, like a method \cil{Init}
      \item One could use a so-called ``fluent style'', with a \cil{Build} object returning \cil{this}, which can be called directly after the object is created
    }}
    \bl{The problem with \cil{Init} or \cil{Build}} {\iz {
      \item Typically, objects always need to be properly initialised
      \item separating the process of creation from that of initialisation is error prone
      \item[$\Rightarrow$] the problem is solved in OOP with a specific programming construct
    }}
}

\fr{The construction of objects}{
     \bl{Constructors of a class}{\iz{
       \item It is them which are called by \cil{new} operator
       \item They resemble methods in structure
       \item They have the same name as the class they are in
       \item No type of return, they can have formal parameters{\iz{
       \item [$ \Rightarrow $] values can then be passed to \cil{new}
       }}
       \item The default constructor (with zero arguments) is implicitly defined only if no more are added - that's why it was allowed to write: \cil{new Point3D()}
     }}
}


\frs{5}{\Cil{Point3D} with a constructor}{
\codeview{1}{5}{31}{\ssmall}{\codepath{Point3DCons/Program.cs}}
}



\fr{A class \Cil{Person}}{
\codeview{1}{5}{34}{\tiny}{\codepath{Person/Program.cs}}
}

\frs{10}{Multiple constructors}{
\codeview{1}{5}{35}{\tiny}{\codepath{PersonMultiple/Program.cs}}
}

\frs{10}{Constructors chaining}{
\codeview{1}{5}{37}{\tiny}{\codepath{PersonChaining/Program.cs}}
}


\frs{10}{State, Getters and Setters}{
    \bl{An object state}{\iz{
        \item an object carries a state, in the form of a structure set of data
        \item internally this is represented by a set of named and typed fields, which are private
        \item externally this is represented by a set of named and typed ``properties''
        \item such properties may or may not overlap with fields
        \item to make such properties accessible to clients, specific methods are needed
    }}
    \bl{Getters and Setters}{\iz{
        \item a common solution in OOP (will see C\# will improve it)
        \item a getter is method \cil{GetXYZ} with 0-args, returning the property \cil{XYZ}'s value, and typically causing no side-effect
        \item a getter is a method \cil{SetXYZ} taking the property \cil{XYZ}'s value and returning nothing
        \item properties that one only wants to read have no setter, and vice-versa for getters
    }}
}

\frs{5}{\Cil{Person} with Getters and Setters}{
\codeview{1}{18}{48}{\tiny}{\codepath{PersonGetters/Program.cs}}
}

\fr{Client code for \Cil{Person}}{
\codeview{2}{7}{16}{\scriptsize}{\codepath{PersonGetters/Program.cs}}
}

\fr{Expression-bodied members}{
    \bl{Syntax: \texttt{<member> => expression; }}{\iz{
        \item can be used for methods and constructors
        \item when their body is a single return of an expression, of just a single statement...
        \item you can directly indicate the signature, \texttt{=>}, and that expression/statement
        \item it makes your programs more short and readable
    }}
}

\fr{\Cil{Person} with Expression-bodied methods}{
\codeview{1}{18}{39}{\ssmall}{\codepath{PersonExpBody/Program.cs}}
}

\fr{Immutability}{
    \bl{Design for immutability}{\iz{
        \item by choosing which property has a Setter we can decide that there is information that cannot be changed, and this is important to avoid clients to badly affect the behaviour of our objects
    }}
    \bl{Readonly fields}{\iz{
        \item the same has to be done for fields: if a field is initialised at construction time and then never changed, we shall use modifier \cil{readonly}
        \item this enhance clarity of programs, and the compiler check we do not alter such fields
    }}
}


\frs{15}{Properties}{
    \bl{Improving over Get/Set accessors}{\iz{
        \item C\# introduces a programming construct for properties as we defined
        \item a property is directly perceived by the client as a sort of field (starting with uppercase)
        \item internally to a class, a property is actually a getter and/or setter with special syntax
    }}
    \bl{Notation}{\iz{
        \item \cil{public <type> <name>\{ get \{...\} set \{...\} \}}
        \item the body of \cil{get} should return a value
        \item the body of \cil{set} can use a special variable \cil{value}
        \item for both we can use expression-bodied get/set
        \item can use expression-bodied readonly property in one line
    }}
    \bl{The special case of auto-implemented properties}{\iz{
        \item if the body of \cil{get} and \cil{set} are entirely skipped, a field with same name of the property is implicitly defined
    }}
}

\fr{\Cil{Person} with Properties}{
\codeview{1}{5}{33}{\tiny}{\codepath{PersonProperties/Program.cs}}
}

\frs{5}{\Cil{Person} with Properties: playing with properties}{
\codeview{1}{20}{50}{\tiny}{\codepath{PersonPropertiesPlay/Program.cs}}
}

\fr{Playing with properties: client code}{
\codeview{2}{7}{18}{\scriptsize}{\codepath{PersonPropertiesPlay/Program.cs}}
}

\frs{10}{Static members}{
    \bl{Instance members (methods and fields)}{\iz{
        \item methods and fields seen so far are called \cil{instance members}, since a client access them indicating as receiver an object (also called, an instance)
        \item namely, they \alert{conceptually} belong to an instance
        \item inside an object we can omit the receiver, which is \cil{this}
        \item recall that a field is part of the object state, a method is a service provided by the object
    }}
    \bl{Static members (methods and fields)}{\iz{
        \item they are obtained with modifier \cil{static}
        \item a client access them indicating as receiver the class in which they are defined
        \item namely, they \alert{conceptually} belong to the class, i.e., the set of all objects of that class
        \item inside a class we can omit the receiver, which is the class itself
        \item inside a static method there's no \cil{this} variable available
        \item they represent C-like pure functions or procedures
    }}
}

\fr{Static members: pragmatics}{
    \bl{Static fields}{\iz{
        \item it is good norm to use static fields only for constants of the class, hence \cil{readonly}
    }}
    \bl{Static methods in module classes}{\iz{
        \item classes modelling C-like sets of algorithms, including only static methods
        \item in C\# such class are themselves \cil{static}, and cannot be instantiated
    }}
    \bl{Static methods in standard classes}{\iz{
        \item adding algorithms/services pertaining the class, but not to be called on a specific object
        \item modern quality approaches prefer them to be moved to module classes
    }}
}

\frs{10}{Static members: \Cil{Point3D}}{
    \codeview{1}{5}{36}{\tiny}{\codepath{Point3DStatic/Program.cs}}
}

\fr{An example module class with only static methods}{
    \codeview{2}{9}{12}{\tiny}{\codepath{Point3DModule/Program.cs}}
    \codeview{1}{15}{37}{\tiny}{\codepath{Point3DModule/Program.cs}}
}

\frs{5}{The procedural vs. OO style of calls}{
    \bl{Procedurale style}{\iz{
        \item the standard way of C
        \item static method call in OOP
        \item it models a pure function/procedure
        \item you pass arguments, get a result, possibly with side-effects
    }}
    \bl{OOS style}{\iz{
        \item can only be simulated in C
        \item instance method call in OOP
        \item it models a message sent to a receiver object
        \item you pass arguments, get a result, possibly with side-effects on the object
        \item could be simulated by passing the receiver as additional argument, named \cil{this}
    }}
}

\end{document}
